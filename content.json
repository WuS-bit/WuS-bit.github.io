{"meta":{"title":"WuS-bit","subtitle":"","description":"","author":"Wu Shang","url":"http://WuS-bit.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-14T14:13:11.000Z","updated":"2020-04-16T01:45:40.907Z","comments":true,"path":"categories/index.html","permalink":"http://wus-bit.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-16T03:40:34.000Z","updated":"2020-04-16T03:45:19.995Z","comments":true,"path":"about/index.html","permalink":"http://wus-bit.github.io/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-14T14:05:30.000Z","updated":"2020-04-16T01:47:25.333Z","comments":true,"path":"tags/index.html","permalink":"http://wus-bit.github.io/tags/index.html","excerpt":"","text":""},{"title":"海内存知己","date":"2020-04-15T14:18:11.000Z","updated":"2020-04-16T02:50:57.224Z","comments":true,"path":"friends/index.html","permalink":"http://wus-bit.github.io/friends/index.html","excerpt":"","text":"欢迎留言交换友链:我的博客信息： 名称：WuS-bit头像：https://tva1.sinaimg.cn/large/007S8ZIlly1gdve5b27cyj30qn0qnwfy.jpg地址：https://wus-bit.github.io标签：[java, 数据科学]"}],"posts":[{"title":"基于二分类器的命名实体识别","slug":"基于二分类器的命名实体识别","date":"2020-05-20T01:43:36.000Z","updated":"2020-05-20T01:57:35.313Z","comments":true,"path":"基于二分类器的命名实体识别/","link":"","permalink":"http://wus-bit.github.io/%E5%9F%BA%E4%BA%8E%E4%BA%8C%E5%88%86%E7%B1%BB%E5%99%A8%E7%9A%84%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/","excerpt":"课程第一次大作业：基于北大语料库，做机构实体识别任务。","text":"课程第一次大作业：基于北大语料库，做机构实体识别任务。 基于二分类的命名实体识别实验报告一、概述 作为一个从没有过课程相关内容学习和实操经验的小白，一开始接触到这次作业完全没有头绪，上课时仅能从数学运算的角度理解一些公式和原理，但涉及到作业任务的具体实现，根本没有思路，不知从何处下手。经历了苦闷与挣扎，也在老师和同学的帮助下渐渐有了实现的思路，于是经过自学和不断的“面向搜索引擎编程”解决遇到的各种问题，终于完成了第一次作业。尽管实现过程及结果可能不是最好，但个人对于自己在完成这次作业的过程中取得的收获比较满意。也希望自己在课程后续学习及作业完成过程中继续进步。 二、具体实现过程1. 概述：整个作业实现过程大体分为：处理语料库，特征提取（one-hot编码），训练过程实现。1. 处理语料库初始语料库样例： 要求： 将语料库分为训练集、验证集、测试集。 提取出所有汉字词语（去除标签标记） 提取对应词语的标签作为y 思路及要点： 手工划分语料库为训练集、验证集、测试集 通过文件IO读入语料数据集，转化为内存中的字符串形式 运用正则表达式及python的re模块对字符串进行词语匹配及切割 先匹配并抽取出所有复合机构，将复合机构拆分，并将内部实体的y均标注为1 1234567891011121314# 复合机构的正则表达式 形如[a/nt ... d/n]ntpatt1 = re.compile(r\"\\[[\\u4E00-\\u9FA5\\s/a-z]+]nt\")# 抽取复合机构名# arr 复合机构名列表arr = patt1.findall(txt)# text为将复合机构名替换为空串后剩余文本text = patt1.split(txt)# 获取复合机构的所有实体词加入词语列表k，将词语对应标签列表v全设为1item = arr[j][1:-3] j += 1 temp = re.findall(r\"[\\u4E00-\\u9FA5]+\", item) for i in temp: k.append(i) v.append(1) 处理剩余语料，分别完善对应的词列表和标签列表 123456789101112# 匹配汉字及其标注的正则表达式 形如：主席/n 江/nrfpatt2 = re.compile(r\"[\\u4E00-\\u9FA5]+[/a-z]+\")# 分别找出汉字及其标注，加入对应列表temp = patt2.findall(item) for i in temp: s = re.split(r\"/\", i) if s[1] == 'nt': k.append(s[0]) v.append(1) else: k.append(s[0]) v.append(0) 词列表处理结果样例： 2. 特征提取(one-hot编码)要求：根据训练集语料构建一个500词的词典，将语料中的每一词转化为包括前一词、当前词、后一词信息的1500维向量。 思路及要点： 构建500词词典，取训练集语料词频前499及一个表示非词典的词构成该词典(用词典的第500个位置表示) 12345678910# 训练集词频统计，取词频前499构建词典counts = &#123;&#125;dic = []for key in k1: counts[key] = counts.get(key, 0) + 1items = list(counts.items())items.sort(key=lambda x: x[1], reverse=True)for i in range(499): key, count = items[i] dic.append(key) 将词语列表中的词转为one-hot向量（封装成一个函数，训练过程分批调用）。one-hot编码即：将词语出现在词典中的位置对应的向量维度上置1，其余全置0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# 依据所构建的词典将词语转化成one-hotdef to_one_hot(k, dic, s, n): # 批量处理的起始位置 s = s*n # 词向量列表 tensors = t.zeros(n, 1500) # 遍历k的取词部分 对每一个词构造one-hot for i in range(s, s+n): # 存放前一向词量 x_0 = t.zeros(500) # 存放当前词向量 x_1 = t.zeros(500) # 存放后一词向量 x_2 = t.zeros(500) if i == 0: x_0[499] = 1 try: pos = dic.index(k[i]) except ValueError: x_1[499] = 1 else: x_1[pos] = 1 try: pos_next = dic.index(k[i + 1]) except ValueError: x_2[499] = 1 else: x_2[pos_next] = 1 elif i == k.__len__() - 1: x_2[499] = 1 try: pos = dic.index(k[i]) except ValueError: x_1[499] = 1 else: x_1[pos] = 1 try: pos_pre = dic.index(k[i - 1]) except ValueError: x_0[499] = 1 else: x_0[pos_pre] = 1 else: try: pos_pre = dic.index(k[i - 1]) except ValueError: x_0[499] = 1 else: x_0[pos_pre] = 1 try: pos = dic.index(k[i]) except ValueError: x_1[499] = 1 else: x_1[pos] = 1 try: pos_next = dic.index(k[i + 1]) except ValueError: x_2[499] = 1 else: x_2[pos_next] = 1 temp = t.cat((x_0, x_1, x_2)) tensors[i-s] = temp return tensors 3. 训练过程（选用批量梯度下降）要求：分别使用手动求导和自动求导实现批量梯度下降的训练过程，并计算验证集和测试集F1，当F1出现极值时，学到的参数theta为较优模型参数 思路及要点： 用sigmoid函数表示似然度： $$h_\\theta(Y=1\\mid X) = \\frac{1}{1+e^-\\theta^Tx}$$ $$h_\\theta(Y=0\\mid X) = 1 - \\frac{1}{1+e^-\\theta^Tx}$$ 1train_out = t.sigmoid(theta.mm(x)) 用极大似然估计定义损失函数： $$\\begin{aligned}l(\\theta)=\\log (L(\\theta))&amp;=\\sum_{i=1}^m \\left[y^{(i)}\\log h_\\theta(1\\mid x^{(i)})+(1-y^{(i)})\\log (1-h_\\theta(1\\mid x^{(i)}))\\right]\\&amp;=\\sum_{i=1}^m(y^{(i)}\\log g(\\theta^Tx^{(i)})+(1-y^{(i)})\\log (1-g(\\theta^Tx^{(i)})))\\end{aligned}$$ 1loss += (y[jj]*t.log(train_out) + (t.ones(1, 1) - y[jj])*t.log(t.ones(1, 1)-train_out)) 对损失函数求导并将结果化简： $$\\begin{aligned}\\frac{\\partial l(\\theta)}{\\partial \\theta}&amp; =\\sum_{i=1}^m\\left[ \\frac{y^{(i)}}{g(\\theta^Tx^{(i)})}\\frac{\\partial g(\\theta^Tx^{(i)})}{\\partial \\theta}-\\frac{(1-y^{(i)})}{1-g(\\theta^Tx^{(i)})}\\frac{\\partial g(\\theta^Tx^{(i)})}{\\partial \\theta} \\right]\\&amp; =\\sum_{i=1}^m\\left[\\frac{y^{(i)}}{g(\\theta^Tx^{(i)})}-\\frac{(1-y^{(i)})}{1-g(\\theta^Tx^{(i)})} \\right]g(\\theta^Tx^{(i)})(1-g(\\theta^Tx^{(i)}))x^{(i)}\\&amp; =\\sum_{i=1}^m\\left[y^{(i)}(1-g(\\theta^Tx^{(i)}))-(1-y^{(i)})g(\\theta^Tx^{(i)}) \\right]x^{(i)}\\&amp; =\\sum_{i=1}^m\\left[y^{(i)}-g(\\theta^Tx^{(i)}) \\right]x^{(i)}\\end{aligned}$$ 1grad += ((y[jj]-train_out)*x) 用批量梯度下降更新$\\theta$使得损失函数接近取得极值（全局最优）： $$\\theta := \\theta+\\alpha\\left(\\sum_{i=1}^m\\left[y^{(i)}-g(\\theta^Tx^{(i)}) \\right]x^{(i)} \\right)$$ 1theta = theta + a*grad 手动求导实现批量梯度下降过程代码： 1234567891011121314# 批量梯度下降batch_size = 128for ii in range(k1.__len__()//batch_size): x_1 = utils.to_one_hot(k1, dic, ii, batch_size) y = t.tensor(v1[ii*batch_size:ii*batch_size+batch_size]) loss = t.zeros([1, 1]) grad = t.zeros(1500, 1) for jj in range(batch_size): x = x_1[jj].view(-1, 1) train_out = t.sigmoid(theta.mm(x)) loss += (y[jj]*t.log(train_out) + (t.ones(1, 1) - y[jj])*t.log(t.ones(1, 1)-train_out)) grad += ((y[jj]-train_out)*x) grad = grad.view(1, 1500) theta = theta + a*grad 自动求导求导实现批量梯度下降过程代码： 1234567891011121314# 批量梯度下降 batch_size = 128 # theta = theta.view(-1, 1) # theta.requires_grad_(True) for ii in range(k1.__len__()//batch_size): x = utils.to_one_hot(k1, dic, ii, batch_size) y = t.tensor(v1[ii*batch_size:(ii+1)*batch_size]).view(-1, 1) g = t.sigmoid(t.mm(x, theta)) loss = t.sum(y*t.log(g) + (1-y)*t.log(1-g)) loss.backward() with t.no_grad(): theta += a*theta.grad theta.grad.zero_() theta1 = theta.view(1, -1) 用验证集、测试集检验模型，计算F1 真实情况\\模型预测 True False True TP FN False FP TN 查准率：$P=\\frac{TP}{\\left(TP+FP \\right)}$ 查全率：$R=\\frac{TP}{(TP+FN)}$$F1-measure = 2\\frac{PR}{P+R}$ 结果分析 （手动求导） 学习率$\\alpha$的选取对训练过程结果的影响：$\\alpha=1$时 迭代轮数\\数据集F1 验证集F1 测试集F1 第一轮 0.66471734 0.69189189 第二轮 0.67116682 0.70119521 第三轮 0.66601562 0.69282814 第四轮 0.66862745 0.69282814 第五轮 0.66862745 0.69282814 第六轮 0.66797257 0.69282814 ​ $\\alpha=0.1$时 迭代轮数\\数据集F1 验证集F1 测试集F1 第一轮 0.66342412 0.69189189 第二轮 0.66731898 0.69189189 第三轮 0.66666666 0.69376693 第四轮 0.67315175 0.69905533 第五轮 0.67380720 0.69905533 第六轮 0.67380720 0.69905533 ​ $\\alpha=0.02$时 迭代轮数\\数据集F1 验证集F1 测试集F1 第一轮 0.33285302 0.39347826 第二轮 0.56746765 0.60915032 第三轮 0.64367816 0.67919463 第四轮 0.66021297 0.69376693 第五轮 0.66213592 0.69553450 第六轮 0.67054263 0.70175438 第七轮 0.67054263 0.70175438 第八轮 0.67054263 0.70175438 分析：通过批量梯度下降的方法往往通过较少次数的迭代学习便可学到较好模型参数，但也与学习率$\\alpha$有关，$\\alpha$选取较小时，往往需要较多次数的迭代。","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"知识工程课程","slug":"深度学习/知识工程课程","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B/"},{"name":"作业一","slug":"深度学习/知识工程课程/作业一","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B/%E4%BD%9C%E4%B8%9A%E4%B8%80/"}],"tags":[{"name":"命名实体识别","slug":"命名实体识别","permalink":"http://wus-bit.github.io/tags/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"}]},{"title":"MyBatis学习","slug":"Mybatis学习","date":"2020-05-09T07:53:24.000Z","updated":"2020-05-17T07:57:15.576Z","comments":true,"path":"Mybatis学习/","link":"","permalink":"http://wus-bit.github.io/Mybatis%E5%AD%A6%E4%B9%A0/","excerpt":"Mybatis框架本文用于记录初学Mybatis框架过程中的知识点，主要依据Mybatis官方手册及B站的学习资源","text":"Mybatis框架本文用于记录初学Mybatis框架过程中的知识点，主要依据Mybatis官方手册及B站的学习资源 一、Mybatis简介1.1Mybatis历史 Mybatis是Apache的一个开源项目iBatis,2010年6月迁移到Google Code，iBatis3.x随之更名为Mybatis。 iBatis一词源于”internet”和”abatis”的组合，是一个基于java的持久层框架。iBatis提供的持久层框架包括SQL Maps 和Data Access Object(DAO) 1.2Mybatis简介 Mybatis是支持定制化SQL、存储过程以及高级映射的优秀的持久层框架 Mybatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集 Mybatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Object，普通的java对象）映射成数据库中的记录。 1.3Mybatis特点 核心sql代码可以自己优化 sql和Java编码分离，一个专注业务，一个专注数据 1.4安装要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于类路径（classpath）中即可。如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中： 12345&lt;dependency&gt; &lt;groupId&gt;&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 二、Mybatis快速使用2.1开发环境准备在maven中添加依赖 2.2创建测试表123456789# 创建库CREATE DATABASE test_mybatis;# 使用库USE test_mybatis# 创建表CREATE table tbl_employee(id INT(11) primary key Auto_Increment,name varchar(255) ); 2.3创建javaBean1234567891011121314151617181920212223242526272829public class Employee &#123; private int id; private String name; public Employee() &#123;&#125; public Employee(int id, String name) &#123; this.id = id; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; // 重写toString()&#125; 2.3创建Mybatis全局配置文件参考Mybatis官方手册：Mybatis-quickStart 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"Employee.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.4创建Mybatis的SQL映射文件(Mapper映射文件)参考Mybatis官方手册：Mybatis-quickStart 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace指定绑定的映射器类（接口）的全类名（全限定名） --&gt;&lt;mapper namespace=\"cn.edu.bit.mybatis.mapper.EmployeeMapper\"&gt; &lt;select id=\"selectEmployee\" resultType=\"cn.edu.bit.mybatis.bean.Employee\"&gt; select * from tbl_employee where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 2.5测试参考Mybatis官方手册：Mybatis-quickStart 123456789101112131415@Testpublic void test() throws Exception &#123; String resource = \"mybatis-config.xml\"; //mabtis全局配置文件位置 InputStream inputStream = Resource.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(inputStream);//通过SqlSessionFactoryBuilder的build()获取SqlSessionFactory的一个实例 SqlSession session = sqlSessionFactory.openSession()//通过sqlSessionFactory的openSession()获取sqlSession实例，sqlSession实例可执行所有的增删改查数据库的方法 try&#123; //使用映射器类mapper接口操作 EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.selectEmployee(10) &#125; finally &#123; session.close() &#125;&#125; 2.6基于Mapper接口 编写Mapper接口 123public interface EmployeeMapper &#123; public Employee selectEmployee(int id);&#125; 完成两个绑定 Mapper接口与Mapper映射文件(.xml)的绑定。在Mapper映射文件中的&lt;mapper&gt;标签中的namespace必须指定为Mapper接口的全类名. Mapper映射文件中的增删查改标签的id必须指定成Mapper接口中的方法名。 获取接口的代理实现对象123456789101112131415 @Testpublic void test() throws Exception &#123; String resource = \"mybatis-config.xml\"; //mabtis全局配置文件位置 InputStream inputStream = Resource.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(inputStream);//通过SqlSessionFactoryBuilder的build()获取SqlSessionFactory的一个实例 SqlSession session = sqlSessionFactory.openSession()//通过sqlSessionFactory的openSession()获取sqlSession实例，sqlSession实例可执行所有的增删改查数据库的方法 try&#123; //使用映射器类mapper接口操作 EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.selectEmployee(10) &#125; finally &#123; session.close() &#125;&#125; 三、Mybatis全局配置文件3.1Mybatis全局配置文件简介 Mybatis的配置文件包含了影响Mybatis行为甚深的设置(settings)和属性(properties)信息。 文件结构如下： configuration 配置 properties 属性 settings 设置 typeAliases 类型命名 typeHandlers 类型处理器 objectFactory 对象工厂 plugins 插件 environments 环境 environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider 数据库厂商标识 mappers 映射器 3.2 properties属性 既可外部配置也可动态替换的，既可以在典型的Java属性文件(.properties)中配置，也可通过properties元素的子元素配置 在类路径下创建一个资源文件，名为dbconfig.properties,通过键值对(key=value)的方式放置，不加其他字符，一条占一行 jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test_mybatisjdbc.username=rootjdbc.password=xxxxxx然后在Mybatis全局配置文件中引入外部资源文件 1234&lt;!-- resource: 从类路径下引入 url: 从网络路径或磁盘路径下引入--&gt;&lt;properties resource=\"dbconfig.properties\"&gt;&lt;/properties&gt; 设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如: 1234567891011&lt;environments default=\"oracle\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载： 首先读取在 properties 元素体内指定的属性。 然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路 径读取属性文件，并覆盖之前读取过的同名属性。 最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。 因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。 settings设置 这是Mybatis极为重要的调整设置，会改变Mybatis的运行时行为 一个完整的settings元素配置实例如下：1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; 较常用的settings设置 设置名 描述 有效值 默认值 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 true false False typeAliases类型别名处理 类型别名是为Java类的全限定名设置一个短的名字，可以方便的引用某个类。通常情况下，都是批量将一个包下的类起别名，就是简单类名小写123456789&lt;!-- 单独给某个类起别名&lt;typeAliases&gt; &lt;typeAlias type=\"类的全限定名\" alias=\"别名\"/&gt;&lt;/typeAliases&gt;--&gt;&lt;typeAliases&gt; &lt;package name=\"cn.edu.bit.mybatis.bean\"/&gt;&lt;/typeAliases&gt; typeHandlers类型处理器 MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。（此块暂不深究) plugins插件MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括： Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed) ParameterHandler (getParameterObject, setParameters) ResultSetHandler (handleResultSets, handleOutputParameters) StatementHandler (prepare, parameterize, batch, update, query) 这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。 通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。（此例来自于Mybatis官网） 123456789101112131415161718// ExamplePlugin.java//注解指定所拦截的方法签名@Intercepts(&#123;@Signature( type= Executor.class, method = \"update\", args = &#123;MappedStatement.class,Object.class&#125;)&#125;)public class ExamplePlugin implements Interceptor &#123; private Properties properties = new Properties(); public Object intercept(Invocation invocation) throws Throwable &#123; // implement pre processing if need Object returnObject = invocation.proceed(); // implement post processing if need return returnObject; &#125; public void setProperties(Properties properties) &#123; this.properties = properties; &#125;&#125; 123456&lt;!-- mybatis-config.xml --&gt;&lt;plugins&gt; &lt;plugin interceptor=\"org.mybatis.example.ExamplePlugin\"&gt; &lt;property name=\"someProperty\" value=\"100\"/&gt; &lt;/plugin&gt;&lt;/plugins&gt; 上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。 environments环境设置 MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单： 每种环境使用一个environment标签进行配置 可以通过environments标签中的defualt属性指定一个环境的标识符来快速的切换环境 environment指定具体环境 id:指定当前环境的唯一标识 必须配置transactionManager和dataSource属性123456789101112131415161718192021222324&lt;environments default=\"mysql\"&gt; &lt;environment id=\"mysql\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"oracle\"&gt; &lt;transactionManager type=\"JDBC\"&gt; &lt;property name=\"...\" value=\"...\"/&gt; &lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 实际过程中用Spring管理数据源和事务控制。 数据库厂商标识mappers映射器既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 file:/// 形式的 URL），或类名和包名等。 用来在mybatis初始化时，告诉mybatis需要引入哪些Mapper映射文件 mapper逐个注册SQL映射文件 resource: 引入类路径下的文件（通常使用）url: 引入网络路径或磁盘路径下的文件class: 引入Mapper接口。有SQL映射文件：要求与Mapper接口同名同位置 没有AQL映射文件：使用注解在接口方法上写SQL语句 四、Mybatis映射文件4.1Mybatis映射文件简介 MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。 SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）： cache – 该命名空间的缓存配置。cache-ref – 引用其它命名空间的缓存配置。resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参 数映射。这里不会介绍此元素。sql – 可被其它语句引用的可重用语句块。insert – 映射插入语句。update – 映射更新语句。delete – 映射删除语句。select – 映射查询语句。 4.2 insert|update|delete|select select12//mapper 接口方法public Employee getEmployeeById(Integer id); 123&lt;select id=\"getEmployeeById\" resultType=\"cn.edu.bit.bean.Employee\"&gt; select * from tbl_employee where id = $&#123;_parameter&#125;&lt;/select&gt; insert12//mapper接口public Integer insertEmployee(Employee employee); 123&lt;insert id=\"insertEmployee\" parameterType=\"cn.edu.bit.bean.Employee\"&gt;insert into tbl_employee(id, name) values(#&#123;id&#125;, #&#123;name&#125;)&lt;/insert&gt; update12//mapper接口public Boolean updateEmployee(Employee employee); 123&lt;update id=\"updateEmployee\" parameterType=\"cn.edu.bit.bean.Employee\"&gt;update tbl_employee set name = #&#123;name&#125; where id = #&#123;id&#125;&lt;/update&gt; delete12//mapper接口public void deleteEmployeeById(Integer id); 123&lt;delete id=\"deleteEmployeeById\"&gt;delete from tbl_employee where id = #&#123;id&#125;&lt;/delete&gt; 4.3主键如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了 123&lt;insert id=\"insertEmployee\" parameterType=\"cn.edu.bit.bean.Employee\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt;insert into tbl_employee(name) values(#&#123;name&#125;)&lt;/insert&gt; 4.4参数传递参数的获取方式： #{key}: 获取参数的值，预编译到SQL中，安全。 ${key}: 获取参数的值，拼接到SQL中，可能存在SQL注入。默认情况下，使用 #{} 参数语法时，MyBatis 会创建 PreparedStatement 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 4.5 resultType自动映射 autoMappingBehavior默认是PARTIAL（如果为null，会取消自动映射）,开启自动映射的功能。唯一的要求是列名和javabean属性名一致。 数据库字段命名规范，POJO属性符合驼峰命名法，如：A_COLUMN aColumn,因此需将settings下的mapUnderscoreToCamelCase=true 4.6 resultMap 自定义结果映射 自定义resultMap，实现高级结果映射 id: 用于完成主键值的映射 result: 用于完成普通列的映射 association: 复杂类型映射 connection: 集合类型映射例如：实现员工表和部门表的联合查询，员工对象有一个(通常使用association)部门对象123456789101112131415&lt;resultMap id=\"WithDeptResultMap\" type=\"cn.edu.bit.crud.bean.Employee\"&gt; &lt;!-- column对应数据库中属性， property对应POJO中的字段 --&gt; &lt;id column=\"emp_id\" jdbcType=\"INTEGER\" property=\"empId\" /&gt; &lt;result column=\"emp_name\" jdbcType=\"VARCHAR\" property=\"empName\" /&gt; &lt;result column=\"gender\" jdbcType=\"CHAR\" property=\"gender\" /&gt; &lt;result column=\"email\" jdbcType=\"VARCHAR\" property=\"email\" /&gt; &lt;result column=\"dept_id\" jdbcType=\"INTEGER\" property=\"deptId\" /&gt; &lt;!-- 指定联合查询出的department成员信息封装 --&gt; &lt;association property=\"department\" javaType=\"cn.edu.bit.crud.bean.Department\"&gt; &lt;id column=\"dept_id\" property=\"deptId\" /&gt; &lt;result column=\"dept_name\" property=\"deptName\" /&gt; &lt;/association&gt;&lt;/resultMap&gt; 五、动态SQL六、MyBatis逆向工程6.1 逆向工程简介MyBatis Generator: 简称MBG，是一个专门为MyBatis框架使用者定制的代码生成器，可以快速的根据表生成对应的Mapper映射文件、Mapper映射器接口，以及javabean类。支持基本得增删改查以及QBC风格的条件查询。但是表连接、存储过程等复杂的sql定义需要手工编写。 6.2 逆向工程的配置 导入逆向工程的jar包或maven添加相应依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.generator/mybatis-generator-core --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.7&lt;/version&gt;&lt;/dependency&gt; 编写MBG的配置文件(重要几处配置)，具体可参照[官网手册][http://mybatis.org/generator/quickstart.html] 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt;&lt;!-- targetRuntime: 执行生成的逆向工程版本 MyBatis3Simple:生成基本的CRUD MyBatis3:生成带条件的CRUD--&gt; &lt;context id=\"simple\" targetRuntime=\"MyBatis3\"&gt; &lt;jdbcConnection driverClass=\"com.mysql.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/mbg_test\" userId=\"root\" password=\"xxxxxx\"&gt; &lt;/jdbcConnection&gt;&lt;!-- javabean的生成策略targetPackage：生成javabean的位置--&gt; &lt;javaModelGenerator targetPackage=\"cn.edu.bit.mbg.beans\" targetProject=\"src/main/java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt;&lt;!-- sql映射文件的生成策略 --&gt; &lt;sqlMapGenerator targetPackage=\"example.mapper\" targetProject=\"src/main/resources\"/&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"mapper\" targetProject=\"src/main/resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt;&lt;!-- mapper接口的生成策略 --&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.edu.bit.crud.dao\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt;&lt;!-- 逆向分析的表 --&gt; &lt;table tableName=\"tbl_emp\" domainObjectName=\"Employee\"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 逆向生成器测试代码 1234567891011 @Test public void testMbg() throws Exceptionn &#123;List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(\"mbg.xml\");//mbg配置文件 ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; 七、ssm整合（概述） 搭建环境 spring + springMVC 在web.xml中配置：springMVC的前端控制器，实例化spring容器的监听器，字符编码过滤器，REST过滤器创建spring的配置文件：applicationContext.xml:组件扫描、连接池、事务……创建springMVC配置文件：springmvc.xml: 组件扫描、视图解析器…… mybatis逆向工程配置 spring + mybatis: mybatis的sqlSession的创建，mapper接口的代理实现类","categories":[{"name":"java","slug":"java","permalink":"http://wus-bit.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"http://wus-bit.github.io/categories/java/%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"java/框架/Mybatis","permalink":"http://wus-bit.github.io/categories/java/%E6%A1%86%E6%9E%B6/Mybatis/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://wus-bit.github.io/tags/Mybatis/"}]},{"title":"conda安装pytorch","slug":"conda安装pytorch","date":"2020-04-27T07:53:24.000Z","updated":"2020-04-27T07:55:47.100Z","comments":true,"path":"conda安装pytorch/","link":"","permalink":"http://wus-bit.github.io/conda%E5%AE%89%E8%A3%85pytorch/","excerpt":"conda安装pytorch因课程学习需要，刚刚开始接触pytorch,因此本文仅简单讲述如何通过conda安装pytorch，记录自己安装操作过程，并不对pytorch过多介绍，若后期对其深入一二，可能会写一篇文章简单记录学习看法。","text":"conda安装pytorch因课程学习需要，刚刚开始接触pytorch,因此本文仅简单讲述如何通过conda安装pytorch，记录自己安装操作过程，并不对pytorch过多介绍，若后期对其深入一二，可能会写一篇文章简单记录学习看法。 一、前提：已安装anaconda，了解基本操作基于Anaconda可以便捷地获取包并对包进行管理。若尚未安装可参照该文进行安装配置：安装Anaconda &amp; conda指令入门 - xuzf 二、安装过程 在确保安装好anaconda且添加好镜像(详情见上文推荐博客)之后，先进入其官网转转：pytorch官网get-start 为避免框架之间包冲突，因此先创建一个虚拟环境，在此环境下进行后续操作 创建环境：conda create -name env_name python=3.7 (env_name替换为自己的环境名)进入环境：conda activate env_name 安装gpu版pytorch 安装指令：conda install pytorch torchvision cudatoolkit注：不要按照官网指令后面加：-c pytorch，否则无法用到镜像源此步过程中可能较多次出现如下问题：保持耐心，多次尝试！ 安装成功后，进行测试","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"pytorch安装","slug":"深度学习/pytorch安装","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"pytorch学习","slug":"pytorch学习","permalink":"http://wus-bit.github.io/tags/pytorch%E5%AD%A6%E4%B9%A0/"}]},{"title":"事务-系统恢复-并发控制","slug":"事务-系统恢复-并发控制","date":"2020-04-27T07:22:42.000Z","updated":"2020-05-11T13:59:28.570Z","comments":true,"path":"事务-系统恢复-并发控制/","link":"","permalink":"http://wus-bit.github.io/%E4%BA%8B%E5%8A%A1-%E7%B3%BB%E7%BB%9F%E6%81%A2%E5%A4%8D-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/","excerpt":"本文用以记录数据库概念专业课学习过程中事务，系统恢复，并发控制章节中的重要概念","text":"本文用以记录数据库概念专业课学习过程中事务，系统恢复，并发控制章节中的重要概念 事务一、事物的概念： 事务是构成单一逻辑工作单元的操作的集合。比如：将钱从一个账户转到另一个帐户就是一个事务，该事务包括分别对两个庄户的更新操作。 二、事务的特性（ACID） 原子性(Atomicity)：事务是不可分的。事务的所有动作要么全部执行，要么由于出错而撤销事务的影响。 一致性(consistency)：事务产生的结果只能使数据库从一个状态转移到另一状态且保持一致。即当事务成功提交时，保存一致性结果。而当事务尚未完成就中断时，应回滚事务部分操作对数据库的影响。 隔离性(isolation)：事务的隔离性是指一个事务的执行不能影响到另一个事务，即一个事务的内部操作相对于外部事务是隔离的。 持久性(durability)：一个事务成功完成后，他对数据库的修改必须是永久的，即使出现系统故障。 三、事务的状态 活跃的(active)：初始状态，事务执行过程中处于这个状态。 部分提交(partially committed)：事务的最后一条语句执行后。此时，事务中对数据的操作已经全部完成，但结果数据还驻留在内存中。因此，如果在此状态时，系统出现故障仍可能使事务不得不终止 失败的(failed)：如果事务不能正常执行，事务就进入失败状态。这意味着事务没有成功地完成，必须回滚。回滚（Rollback）就是撤消事务已经做出任何数据更改。一旦事务造成的所有更改被撤消，我们就说事务已回滚。 中止的(aborted)：事务回滚并且数据库已经恢复到事务执行前的状态。 提交状态(committed)： 事务成功完成后。向日志记录中写入一条事务日志信息，并将事务对数据的更改完全写入磁盘时，标志着事务成功完成，这时事务就进入了提交状态。事务成功执行之后，更新结果转存到永久存储器上，因此，事务一旦提交，即使出现了故障，事务所做的数据更新也能在系统重新启动后恢复。 > graph LR A(活跃状态) -->B(部分提交状态) A(活跃状态) -->C(失败状态) B(部分提交状态) -->C(失败状态) B(部分提交状态) -->D(提交状态) C(失败状态) -->E(中止状态) 恢复系统四、故障分类 事务故障：有两种错误可能造成事务执行失败。 逻辑错误：事务由于内部条件而无法正常执行。如非法输入，超出资源等。如在转账事务中需要将一笔金额由一个账户转入另一个账户，但在操作过程中发现余额不够，不能转出。这种情况可由应用程序安排一个ROLLBACK中止事务的执行。该类错误由程序自身解决。 系统错误：系统进入一种不良状态（如死锁），事务无法继续执行。由系统处理。 系统崩溃：系统故障是指造成系统停止运行的任何事件，如硬件故障、操作系统或DBMS故障、突然停电等。这些情况发生时，正在执行着的所有事务将突然中断，导致内存中保留的事务数据都被丢失，数据可能处在不一致的状态。 磁盘故障：存储设备故障主要指辅助存储的介质受到破坏，如磁盘的磁头碰撞使部分磁介质损坏等。这类故障不但影响活动着的所有事务，而且使被损坏介质的数据丢失，数据库遭到严重破坏。 五、数据库恢复技术 基本原理：建冗余数据，即利用存储在系统其他地方（与数据分离）的冗余数据来实现恢复。 建立冗余数据的常用技术： 数据转储 记录日志文件 数据转储：DBA定期地将整个数据库复制到磁带或另一个磁盘上作为备份保存。 转储方式： 静态转储与动态转储 海量转储与增量转储 基于日志的数据库恢复：在修改数据库本身之前，首先向稳定存储器中输入修改描述信息，再执行修改操作，以确保已提交事务的修改能永久存储，中止的事务可回滚。日志记录技术要保证先写日志，再修改数据 日志记录的基本格式： 事务标识(Ti)：执行写操作事务的唯一标识 数据项标识(Xj)：所写数据项的唯一标识。通常是数据项在磁盘上的位置，包括数据项所驻留的块的块标识及块内偏移量。 旧值(V1)：数据项的写前值。 新值(V2)：数据项的写后值。一般表示未&lt;Ti, Xj, V1, V2&gt;。&lt;Ti start&gt; 事务Ti开始。&lt;Ti commit&gt; 事务Ti提交，表示事务对数据库的所有修改已提交到缓冲区，不能确定是否更新了磁盘。&lt;Ti abort&gt; 事务Ti中止。 基于日志的恢复技术： redo：对于已提交的写操作，当系统发生故障崩溃时，用redo重做事务，恢复已完成的事务。 undo：对于修改了数据库但未提交的事务，利用undo撤销事务的影响。 六、检查点恢复技术 检查点的引入：为减少日志记录的搜索规模并减少重复的redo操作，引入检查点技术，即在日志文件中加一个表示数据库是否正常运行的标识。检查点写入时保证（1）此时不允许有任何更新操作（2）将所有更新过的缓冲块写入磁盘(保证检查点之前已提交的事务已写入磁盘，中止事务已回滚) 写入检查点： 检查点记录内容： 建立检查点时刻所有正在执行的事务清单（以&lt;Ti commit&gt;, &lt;Ti abort&gt;作为执行完成标识） 这些事务最近一个日志记录的地址 检查点的执行过程： 将当前位于主存的所有日志记录输出到稳定存储器。 将所有修改操作结果的缓冲块写入磁盘 将一个日志记录&lt;checkpoint L&gt;写入稳定存储器，L是建立检查点时刻所有正在执行的事务清单 将检查点记录在日志文件中的地址写入重启动文件。 利用价差点的恢复步骤： 在重启动文件中找到最后一个检查点记录 将检查点时刻事务清单中的事务暂时 放到undo队列。 从检查点开始正向扫描日志文件， 若有新开始的事务，暂时放入Undo队列。 若有提交事务Tj，把Tj从Undo队列移到redo队列 反向扫描日志文件对undo队列中的事务进行undo 再次正向扫描，对redo 队列中的事务进行redo 七、数据库的镜像恢复技术（涉及负载均衡，主从复制等后期补充） 概念：为预防介质故障，DBA周期性地转储数据库。 使用： 出现介质故障： 可由镜像磁盘继续提供使用 同时DBMS自动利用镜像磁盘数据进行数据库恢复 未出现故障时 主从复制、读写分离：对于并发操作，一个用户对数据库加排他锁，其他用户可对镜像进行读取操作，提高并发性 负载均衡 并发控制八、并发操作带来的数据不一致性： 丢失更新：事务1和事务2从数据库读入同一数据并先后修改，后提交的事务结果破坏了先提交事务的更新结果，导致先提交事务的修改丢失。 读“脏”数据：事务1修改了某一数据，但还未提交，此时事务2读到了事务1所修改的数据，后续事务1可能因为某种原因被撤销，事务1回滚，则事务2读到的就是与数据库中不一致的数据，称为脏读。 不可重复读（包括幻象读）：在事务执行过程中，事务1读取某一数据后，事务2对同一数据执行更新操作并且完成提交，使得事务1再次读取该数据时，发现与前一次所读不同，称之为不可重复读。若事务2执行的是插入或删除操作，会使事务1前后两次读出的数据数量不同，称之为幻象读。 数据库的事务隔离级别 隔离级别 描述 读未提交(READ UNCOMMIT) 允许事务读取其他事务未提交的数据，脏读、不可重复读、幻象读都会出现 读已提交(READ COMMITED) 只允许事务读取其他事务已提交的数据，可避免脏读，会出现不可重复读和幻读现象，也是大多数数据库的默认隔离级别，mysql不是 可重复读(REPEATABLE READ) 确保某一事务多次读取同一数据结果相同（其他事务不可update该数据），但未解决幻读现象（其他事务可insert），Mysql的默认隔离级别 可串行化(SERIALIZABLE) 强制所有事务串行执行，在这个事务持续期间，禁止其他事务对该表执行插入、更新、删除操作，所有并发问题都可以避免，但并发性能十分低下。 数据不一致性的解决方案： 基于锁的协议 基于时间戳协议 基于有效性检查的协议 多版本并发控制 快照隔离 基于锁的协议： 概念：确保隔离性（并发事务的可串行化技术），实际上遵循了一种约束：当一个事务访问某个数据项时，其他任何事务都不能修改这个数据项，实现该约束的最常用方法就是只允许事务访问该事务当前持有锁的数据项。 锁的分类 基本锁的分类： 共享锁（Share lock, S锁、读锁）：若事务T对数据对象A加上S锁，则其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。保证其他事务可以获得对象A的S锁读取A，但不可对A修改，直到A上无S锁，事务才可对A加X锁，更新A 排他锁（eXclusive lock，X锁，写锁）：若事务T对数据项A加X锁，则只允许T读取和修改A，其他事务不能再对A加任何类型的锁。 封锁协议：运用封锁方法进行并发控制时，对数据对象加锁时需要约定的规则。 何时申请锁持锁时间何时释放锁封锁协议分类： 一级封锁协议：事务T在修改数据A前必须先对其加X锁，直到事务结束才释放，不会丢失修改，但在读数据时不加锁，会产生脏读和不可重复读。 二级封锁协议：在一级封锁协议基础上，事务T在读取数据A之前必须先对其加S锁，读完即可释放S锁，可防止脏读，但不能避免不可重复读。 三级封锁协议：在二级封锁协议的基础上，S锁要保持到该事务结束才释放。 两阶段封锁协议：最常用的封锁协议。理论上可以证明两阶段锁协议产生的是可串行化调度。两阶段封锁是指事务必须分两个阶段对数据项加锁和解锁。 第一阶段是获得锁，也称扩展阶段：这个阶段事务可以申请获得任何数据项上的任何类型 的锁，但不可释放任何锁。第二阶段是释放锁，也称收缩阶段。这个阶段事务可以释放任何数据项上的任何锁，但不可获 得锁。遵循两阶段锁的事务，并行执行的结果一定是正确的，但没有避免死锁（不是一次封锁法） 死锁：死锁是指同时处在申请锁的等待状态的两个或多个事务相互封锁了对方请求的资源，使得没有任何一个事务能获得足够资源运行完毕，而永远等待下去。预防死锁的方法有： 死锁预防：针对于系统进入死锁状态概率较高的情形 一次封锁法：在事务开始前将事务可能用到的数据项全部封锁 顺序封锁法：预先对数据对象规定一个封锁顺序，事务按改顺序实行封锁 使用抢占与事务回滚：基于时间戳决定事务是否回滚以释放另一事务所申请的锁 死锁的检测与恢复：允许死锁发生，由DBMS定期检查是否产生了死锁，并设法解除。死锁检测方法： 超时法：如果一个事务等待时间超过了时限则认定为死锁。 事务等待图法：用一个有向图表示事务间申请锁的等待关系，若存在回路则产生了死锁 死锁的恢复：选择一个处理死锁代价最小的事务将其回滚 .","categories":[{"name":"数据库课程","slug":"数据库课程","permalink":"http://wus-bit.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/"},{"name":"事务、恢复系统、并发控制","slug":"数据库课程/事务、恢复系统、并发控制","permalink":"http://wus-bit.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/%E4%BA%8B%E5%8A%A1%E3%80%81%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"}],"tags":[{"name":"数据库课程学习","slug":"数据库课程学习","permalink":"http://wus-bit.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"}]},{"title":"explain关键字","slug":"explain关键字","date":"2020-04-20T08:41:57.000Z","updated":"2020-04-20T14:41:02.731Z","comments":true,"path":"explain关键字/","link":"","permalink":"http://wus-bit.github.io/explain%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"概要在MySQL中，可以使用explain关键字来获取模拟优化器执行SQL语句的结果，从而知道MySQL是如何执行查询语句的，进而分析查询语句或是表结构的性能瓶颈，方便进行性能优化。","text":"概要在MySQL中，可以使用explain关键字来获取模拟优化器执行SQL语句的结果，从而知道MySQL是如何执行查询语句的，进而分析查询语句或是表结构的性能瓶颈，方便进行性能优化。 Explain关键字语法： explain + SQL；先上一个demo，留下印象： Explain中的列一、id列总是一组数字，是select查询的序列号，用来标识查询中执行select子句或操作表的顺序。 情况分析 id相同时，从上到下顺序执行操作表（mysql的查询计划是左深树） id不同时，id值越大越先执行 当查询语句不含子查询或联合(Union)时id总为1 当出现子查询时，id会增大 二、select_type表示查询类型 SIMPLE:简单的select查询，查询中不包括子查询或union PRIMARY:查询中包括任何复杂的子部分，最外层查询被标记为primary SUBQUERY:在select或where子句中的子查询 DERIVED:from子句中的子查询被标记为derived(衍生)，MySQL会递归地执行这些子查询，结果放在临时表 UNION：出现在UNION后的那个select查询会被标记为UNION UNION RESULT:从UNION表获取结果的select 三、table表示该查询是关于的那张表 四、type显示查询使用了哪种类型(访问类型) 常见访问类型效率从最好到最差：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;all一般来说，查询至少到range级别，最好达到ref system：表中只有一行记录。 const: 通常是以primary key 或 unique索引作为where子句，且比较条件是键可取值中 的一个常量，通过一次索引便可找到。例如：select * from st where id = 1; eq_ref: 这种访问类型，MySQL知道最多只返回一条符合条件的记录。也是以主键或唯一性索引查找，但比较条件不是常量（另一表中的参考值）。 ref: 用非唯一性索引查找，返回匹配某单个值的所有行。是查找和扫描的混合体。 range: 范围扫描，即一个限制范围内的索引全扫描，常用于where子句中含between,&gt;,&lt;等范围条件的情况。 index: 用索引进行的全表扫描。 all: 全表扫描。 五、possible_keys表示查询可能使用到哪些索引，基于查询访问的列(select子句中的字段)和比较操作符来判断的。 六、key:显示查询使用的索引，如果为null，则未使用索引。若使用覆盖索引^标注，则该索引不会出现在possible_key中。 七、key_len:表示索引使用的字节数。对于复合索引，key_len可以帮助判断是否充分用上索引，判断多列索引中用到哪些列。 八、ref:显示了key中索引查找时，作为查找条件用到的列或常量。 九、rows根据表统计信息及索引选用情况，大致估算找到所需记录需要读取的行数。不是结果集行数。 十、extra:包含不适合出现在其他列的额外重要信息。 using filesort(避免出现): MySQL对数据使用一个外部的索引排序，而不是按照表内的索引顺序读取。MySQL中无法用索引完成的排序操作成为“文件排序”。（排序的字段未使用到索引） using temporary(避免出现): 使用临时表保存中间结果。常见于order by 和 group by。 using index: select操作使用了覆盖索引，避免了对数据行的操作。效率不错。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://wus-bit.github.io/categories/mysql/"},{"name":"explain关键字","slug":"mysql/explain关键字","permalink":"http://wus-bit.github.io/categories/mysql/explain%E5%85%B3%E9%94%AE%E5%AD%97/"}],"tags":[{"name":"mysql基础","slug":"mysql基础","permalink":"http://wus-bit.github.io/tags/mysql%E5%9F%BA%E7%A1%80/"}]},{"title":"markdown基本操作","slug":"markdown基本操作","date":"2020-04-15T13:20:38.000Z","updated":"2020-04-16T01:50:28.004Z","comments":true,"path":"markdown基本操作/","link":"","permalink":"http://wus-bit.github.io/markdown%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","excerpt":"作为一个markdown初学者，仅以此文作为markdown基本语法实操练习，及发文章的demo。文中涉及了markdown的基本语法，供在源代码模式下记忆练习。 加油！！！","text":"作为一个markdown初学者，仅以此文作为markdown基本语法实操练习，及发文章的demo。文中涉及了markdown的基本语法，供在源代码模式下记忆练习。 加油！！！ 一级标题二级标题三级标题写博客：git bash里输入指令： hexo new &lt;文件名&gt; 在_posts里生成新的.md文件，编辑即可 hexo g &amp;&amp; hexo d 我也是一级标题我是二级标题加粗我也是粗体斜体我也是斜体我也是斜体加粗斜体加粗删除线==高亮==我有下划线这里创建了一个关于我的脚注[^ME][^ME]: 我是Wu 我是^上标^我是下标== (3)列表== *号 +号 -号都能列表 一二三四五 上山打老虎 一二三四五 列表嵌套只需在子列表中的选项添加四个空格即可： 第一个列表： 第一个元素 第2个 第二个： 1 2 区块配列表： Java面向对象： 封装性继承性多态性 代码块：printf() 1234int main()&#123; return 0;&#125; public class Person { private string name; }链接这是我的博客主页：WuS-bit百度：http://baidu.com高级链接：这个链接用1作为网址变量 [baidu][1]在文档末尾给1赋值 == 表格 == mon tue wed thu fri 上山 上山 上山 伤寒 上山 1printf(); 代码块：public static void main(){ system.out.println(&quot;Hello World&quot;); }段落：Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。 插入图片：开头一个感叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的&apos;title&apos;属性的文字。这是我的微信图像： 标签指定图片大小：高级： 横向流程图源码格式： graph LR A[方形] -->B(圆角) B --> C{条件a} C -->|a=1| D[结果1] C -->|a=2| E[结果2] F[横向流程图] 竖向流程图源码格式： graph TD A[方形] --> B(圆角) B --> C{条件a} C --> |a=1| D[结果1] C --> |a=2| E[结果2] F[竖向流程图] 标准流程图源码格式： 标准流程图源码格式（横向）： UML时序图源码样例： 12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？ UML时序图源码复杂样例： 1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩 UML标准时序图样例： %% 时序图例子,-> 直线，-->虚线，->>实线箭头 sequenceDiagram participant 张三 participant 李四 张三->王五: 王五你好吗？ loop 健康检查 王五->王五: 与疾病战斗 end Note right of 王五: 合理 食物 看医生... 李四-->>张三: 很好! 王五->李四: 你怎么样? 李四-->王五: 很好! 甘特图样例： %% 语法示例 gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求 :done, des1, 2014-01-06,2014-01-08 原型 :active, des2, 2014-01-09, 3d UI设计 : des3, after des2, 5d 未来任务 : des4, after des3, 5d section 开发 学习准备理解需求 :crit, done, 2014-01-06,24h 设计框架 :crit, done, after des2, 2d 开发 :crit, active, 3d 未来任务 :crit, 5d 耍 :2d section 测试 功能测试 :active, a1, after des3, 3d 压力测试 :after a1 , 20h 测试报告 : 48h [1]: http://baidu.comst=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框(是或否?) sub1=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st->op->cond cond(yes)->io->e cond(no)->sub1(right)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: 开始框 op=>operation: 处理框 cond=>condition: 判断框(是或否?) sub1=>subroutine: 子流程 io=>inputoutput: 输入输出框 e=>end: 结束框 st(right)->op(right)->cond cond(yes)->io(bottom)->e cond(no)->sub1(right)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","categories":[{"name":"学习效率","slug":"学习效率","permalink":"http://wus-bit.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/"},{"name":"markdown","slug":"学习效率/markdown","permalink":"http://wus-bit.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/markdown/"}],"tags":[{"name":"markdwon入门","slug":"markdwon入门","permalink":"http://wus-bit.github.io/tags/markdwon%E5%85%A5%E9%97%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-04-14T10:51:22.914Z","updated":"2020-04-15T13:12:06.205Z","comments":true,"path":"hello-world/","link":"","permalink":"http://wus-bit.github.io/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"知识工程课程","slug":"深度学习/知识工程课程","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B/"},{"name":"作业一","slug":"深度学习/知识工程课程/作业一","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9F%A5%E8%AF%86%E5%B7%A5%E7%A8%8B%E8%AF%BE%E7%A8%8B/%E4%BD%9C%E4%B8%9A%E4%B8%80/"},{"name":"java","slug":"java","permalink":"http://wus-bit.github.io/categories/java/"},{"name":"框架","slug":"java/框架","permalink":"http://wus-bit.github.io/categories/java/%E6%A1%86%E6%9E%B6/"},{"name":"Mybatis","slug":"java/框架/Mybatis","permalink":"http://wus-bit.github.io/categories/java/%E6%A1%86%E6%9E%B6/Mybatis/"},{"name":"pytorch安装","slug":"深度学习/pytorch安装","permalink":"http://wus-bit.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/pytorch%E5%AE%89%E8%A3%85/"},{"name":"数据库课程","slug":"数据库课程","permalink":"http://wus-bit.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/"},{"name":"事务、恢复系统、并发控制","slug":"数据库课程/事务、恢复系统、并发控制","permalink":"http://wus-bit.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B/%E4%BA%8B%E5%8A%A1%E3%80%81%E6%81%A2%E5%A4%8D%E7%B3%BB%E7%BB%9F%E3%80%81%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"},{"name":"mysql","slug":"mysql","permalink":"http://wus-bit.github.io/categories/mysql/"},{"name":"explain关键字","slug":"mysql/explain关键字","permalink":"http://wus-bit.github.io/categories/mysql/explain%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"学习效率","slug":"学习效率","permalink":"http://wus-bit.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/"},{"name":"markdown","slug":"学习效率/markdown","permalink":"http://wus-bit.github.io/categories/%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87/markdown/"}],"tags":[{"name":"命名实体识别","slug":"命名实体识别","permalink":"http://wus-bit.github.io/tags/%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://wus-bit.github.io/tags/Mybatis/"},{"name":"pytorch学习","slug":"pytorch学习","permalink":"http://wus-bit.github.io/tags/pytorch%E5%AD%A6%E4%B9%A0/"},{"name":"数据库课程学习","slug":"数据库课程学习","permalink":"http://wus-bit.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/"},{"name":"mysql基础","slug":"mysql基础","permalink":"http://wus-bit.github.io/tags/mysql%E5%9F%BA%E7%A1%80/"},{"name":"markdwon入门","slug":"markdwon入门","permalink":"http://wus-bit.github.io/tags/markdwon%E5%85%A5%E9%97%A8/"}]}